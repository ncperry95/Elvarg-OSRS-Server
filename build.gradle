plugins {
    id 'java'
    id 'application'
}

group = 'com.elvarg'
version = '1.0.0'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // If your repo already provides Netty/Gson, you can keep this empty.
    // If not, uncomment and set versions that match your code:
    // implementation 'io.netty:netty-all:4.1.108.Final'
    // implementation 'com.google.code.gson:gson:2.10.1'

    testImplementation 'junit:junit:4.13.2'
}

application {
    // Entry point
    mainClass = 'com.elvarg.Elvarg'
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

/**
 * Build a separate runnable “fat” JAR (includes runtime deps).
 * This avoids modifying the normal `jar` task and works on Gradle 9.
 */
tasks.register('fatJar', Jar) {
    group = 'build'
    description = 'Assembles a runnable fat JAR with all dependencies.'

    archiveBaseName.set('elvarg')
    archiveVersion.set('1.0.0')
    archiveClassifier.set('') // no "-all" suffix; simple name

    // Main class so `java -jar` works
    manifest {
        attributes 'Main-Class': application.mainClass.get()
    }

    // Include compiled classes/resources
    from(sourceSets.main.output)

    // Merge runtime dependencies into the JAR
    dependsOn configurations.runtimeClasspath
    from({
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }) {
        // Avoid signature and duplicate issues
        exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA'
        exclude 'module-info.class'
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

/**
 * Keep the Application plugin run task (uses correct runtime classpath automatically).
 * Run with: gradlew run
 */
tasks.named('run') {
    standardInput = System.in
}

/**
 * Optional: create a self-contained distribution with launch scripts.
 * Run with: gradlew installDist  -> build/install/elvarg/bin/elvarg(.bat)
 */
